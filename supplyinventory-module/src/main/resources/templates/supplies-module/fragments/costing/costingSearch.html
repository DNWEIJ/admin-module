<th:block th:fragment="costingSearch(saveButton)">
    <script th:inline="javascript">
        const messageNoCostingSelected = /*[[#{label.costing.search.nocostingselected}]]*/ "";
        const isPriceInfo =   /*[[${salesType.isPriceInfo ?: false}]]*/ false;
        const isEstimate =   /*[[${salesType.isEstimate ?: false}]]*/ false;
    </script>

    <script>
        let baseUrl
        let selectedIndex = -1
        let hxPostUrl
        let selectedFieldDataSet

        // used in checkbox -> hx-on::after-request="setView(this)"/>
        function setView(checkbox) {
            document.getElementById("holder-input").classList.toggle("hidden", checkbox.checked);
            document.getElementById("holder-dropdown").classList.toggle("hidden", !checkbox.checked);
        }

        function updateToSelectedElement(listItems) {
            if (listItems.length === 0) return
            listItems.forEach((li, index) => {
                li.classList.toggle("selected", index === selectedIndex)
                if (index === selectedIndex) {
                    li.scrollIntoView({block: "nearest"})
                }
            })
        }

        function getAllItems() {
            return document.querySelectorAll("#input-costingName li")
        }

        function executeAction(action) {
            if (action === "find") {
                if (!document.getElementById("holder-dropdown").classList.contains("hidden")) {
                    const select = document.getElementById("productsFromCategory");
                    const selectedOption = select.options[select.selectedIndex];
                    selectedFieldDataSet = selectedOption.dataset
                } else {
                    selectedField = Array.from(getAllItems()).filter(li => li.classList.contains("selected"))[0]
                    if (selectedField === undefined) {
                        alert(messageNoCostingSelected)
                        return
                    } else {
                        selectedFieldDataSet = selectedField.dataset
                    }
                }
                if (!isPriceInfo && !isEstimate) {
                    // we're already setting the url, since we will lose the selected field test on hx-get being set instead
                    let costingBatchUrlGet = document.getElementById("batchNumberForCosting")
                    costingBatchUrlGet.setAttribute("hx-get", '/costing/costing/' + selectedFieldDataSet.id + '/batchnumbers')
                }
                // clean up
                document.getElementById("costingFind").value = selectedFieldDataSet.nomenclature
                document.getElementById("input-costingName").innerHTML = ""
                document.getElementById("inputCostingId").value = selectedFieldDataSet.id

                let element = document.getElementById("inputCostingQuantity")
                element.focus()
                element.select()
            }


            if (action === "costingAmount") {
                if (!isPriceInfo && !isEstimate && selectedFieldDataSet !== undefined && selectedFieldDataSet.hasBatch === 'true') {
                    let element = document.getElementById("batchNumberForCosting")
                    let inputElement = document.getElementById("inputBatchNumber")
                    htmx.process(element)
                    htmx.trigger("#batchNumberForCosting", "batchRequired")

                    inputElement.removeAttribute("disabled")
                    inputElement.focus()
                    inputElement.select()
                } else {
                    // finished, post the result to the target
                    htmx.trigger("#costingSearchForm", "submit")
                    resetForNextItem()
                }
            }
            if (action === "batch") {
                if (!isPriceInfo && !isEstimate && (selectedFieldDataSet !== undefined && selectedFieldDataSet.hasSpillage === 'true')) {
                    let element = document.getElementById("spillageForCosting")
                    let inputElement = document.getElementById("inputSpillage")
                    htmx.process(element)
                    htmx.trigger("#spillageForCosting", "spillageRequired")
                    inputElement.removeAttribute("disabled")
                    inputElement.focus()
                    inputElement.select()
                } else {
                    // finished, post the result to the target
                    htmx.trigger("#costingSearchForm", "submit")
                    resetForNextItem()
                }
            }
            if (action === "spillage") {
                // finished, post the result to the target
                htmx.trigger("#costingSearchForm", "submit")
                resetForNextItem()
            }
        }

        function resetForNextItem() {
            // global values
            baseUrl = ''
            selectedIndex = -1
            hxPostUrl = ''
            selectedFieldDataSet = undefined

            document.getElementById("inputCostingQuantity").value = ''
            if (!isPriceInfo && !isEstimate) {
                var element = document.getElementById("inputBatchNumber")
                element.value = ''
                element.setAttribute("disabled", true)

                element = document.getElementById("inputSpillage")
                element.value = ''
                element.setAttribute("disabled", true)
            }
            document.getElementById("inputCostingQuantity").value = '1.0'
            document.getElementById("productsFromCategory").innerHTML = ""

            if (document.getElementById("holder-dropdown").classList.contains("hidden")) {
                element = document.getElementById("costingFind")
                element.value = ''
                element.focus()
                element.select()
            } else {
                document.getElementById("categoryList").focus()
                document.getElementById("categoryList").select()
            }
        }

        function attachMouseHandlersToAllItems() {
            const listItems = getAllItems()

            listItems.forEach((li, index) => {
                li.addEventListener("mouseenter", () => {
                    // highlight hovered item
                    selectedIndex = index
                    updateToSelectedElement(listItems)
                })

                li.addEventListener("click", (event) => {
                    executeAction("find")
                    event.preventDefault()
                })
            })
        }

        document.addEventListener("DOMContentLoaded", () => {

            attachMouseHandlersToAllItems()
            baseUrl = window.location.href
            hxPostUrl = window.location.href
            selectedIndex = -1

            document.getElementById("costingFind").addEventListener("keydown", (event) => {
                const listItems = getAllItems()
                if (listItems.length === 0) {
                    if (event.key === "Enter" || event.key === "Tab") {
                        alert("start typing to search for a product")
                        event.preventDefault()
                        return
                    }
                }
                switch (event.key) {
                    case "ArrowDown":
                        if (selectedIndex < listItems.length - 1) {
                            selectedIndex++
                            updateToSelectedElement(listItems)
                        } else if (selectedIndex === -1 && listItems.length > 0) {
                            selectedIndex = 0
                            updateToSelectedElement()
                        }
                        event.preventDefault()
                        break
                    case "ArrowUp":
                        if (selectedIndex > 0) {
                            selectedIndex--
                            updateToSelectedElement(listItems)
                        }
                        event.preventDefault()
                        break
                    case "Enter":
                    case "Tab":
                        executeAction("find")
                        event.preventDefault()
                        break
                }
            })

            document.getElementById("inputCostingQuantity").addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "Enter":
                    case "Tab":
                        executeAction("costingAmount")
                        event.preventDefault()
                        break
                }
            })
            if (!isPriceInfo && !isEstimate) {
                document.getElementById("inputBatchNumber").addEventListener("keydown", (event) => {
                    switch (event.key) {
                        case "Enter":
                        case "Tab":
                            // we need to have a value
                            if (event.currentTarget.value.trim() === "") {
                                alert("add a batch number")
                                break
                            }
                            executeAction("batch")
                            event.preventDefault()
                            break
                    }
                })

                document.getElementById("inputSpillage").addEventListener("keydown", (event) => {
                    switch (event.key) {
                        case "Enter":
                        case "Tab":
                            // we need to have a value
                            if (event.currentTarget.value.trim() === "") {
                                alert("add a spillage identifier on this product")
                                break
                            }
                            executeAction("spillage")
                            event.preventDefault()
                            break
                    }
                })
            }
            document.getElementById("productsFromCategory").addEventListener("change", function (event) {
                executeAction("find")
                event.preventDefault()
            });

            document.getElementById("costingFind").focus()

        })
    </script>
<style>
    /*checkbox in the middle*/
    .gridSearchCostingWithCheck > div:first-child {
        align-self: center;     /* vertical */
        justify-self: center;   /* horizontal */
    }
</style>
    <form id="costingSearchForm" hx-post="" hx-swap="none">
        <fieldset>
            <div class="gridSearchCostingWithCheck">
                <div>
                    <label for="useDropDown">
                        <input id="useDropDown" class="switch" role="switch" tabindex="0" type="checkbox" th:data-tooltip="#{label.tooltip.costing.usedropdown}" data-placement="right" autocomplete="off"
                               hx-get="/costing/costing/search/costing/dropdown"
                               hx-trigger="click"
                               hx-target="#categoryList"
                               hx-swap="innerHTML"
                               hx-on::after-request="setView(this)"/>
                    </label>
                </div>
                <div id="holder-input" class="holder">
                    <input list="input-costingName" id="costingFind" class="no-break" type="search" name="searchCriteria" th:placeholder="#{label.costing.search.placeholder}"
                           hx-post="/costing/search/costing"
                           hx-trigger="input[this.value.length >=2] changed delay:500ms, keyup[key=='Enter']"
                           hx-target="#input-costingName"
                           hx-swap="innerHTML"
                           hx-indicator="#searching-indicator"
                            autocomplete="off"
                    >
                    <span id="searching-indicator" class="htmx-indicator"><span aria-busy="true">Searching...</span></span>
                    <div class="ac_results_wrapper">
                        <div class="ac_results" id="input-costingName" hx-on::after-swap="attachMouseHandlersToAllItems()"></div>
                    </div>
                </div>
                <div id="holder-dropdown" class="hidden">
                    <!-- options will be filled by hx-target -->
                    <fieldset class="grid">
                        <div><select name="categoryId" id="categoryList" hx-post="/costing/costing/search/costing/dropdown/found/costing" hx-target="#productsFromCategory" hx-swap="innerHTML">
                        </select>
                        </div>
                        <div>
                            <select tabindex="1" id="productsFromCategory">
                                <option disabled readonly selected="true" value="" th:text="#{label.choose}"></option>
                            </select></div>
                    </fieldset>
                </div>
                <div>
                    <input type="hidden" name="inputCostingId" id="inputCostingId"/>
                    <input id="inputCostingQuantity" tabindex="2" name="inputCostingQuantity" size="2" type="number" value="1.0" autocomplete="off">
                </div>
                <th:block th:if="${!salesType.isPriceInfo && !salesType.isEstimate}">
                    <div id="costingBatchNumberContainer">
                        <input list="batchNumberForCosting" id="inputBatchNumber" tabindex="3" size="15" name="inputBatchNumber" type="text" disabled="true"/>
                        <datalist id="batchNumberForCosting"
                                  hx-get="writtenByJavascript"
                                  hx-swap="innerHTML"
                                  hx-target="#batchNumberForCosting"
                                  hx-trigger="batchRequired"
                                  hx-include="#inputBatchNumber">
                        </datalist>
                    </div>
                    <div id="costingSpillageContainer">
                        <input list="spillageForCosting" id="inputSpillage" tabindex="4" name="inputSpillage" size="15" type="text" disabled="true"/>
                        <datalist id="spillageForCosting"
                                  hx-get="writtenByJavascript"
                                  hx-swap="innerHTML"
                                  hx-target="#spillageForCosting"
                                  hx-trigger="spillageRequired"
                                  hx-include="#inputSpillage">
                        </datalist>
                    </div>
                </th:block>
            </div>
        </fieldset>
    </form>
    <script>
        document.getElementById('costingFind').addEventListener('htmx:configRequest', function (evt) {
            document.querySelector('#searching-indicator').classList.add('visible');
        });

        document.getElementById('costingFind').addEventListener('htmx:afterRequest', function (evt) {
            document.querySelector('#searching-indicator').classList.remove('visible');
        });
    </script>
</th:block>